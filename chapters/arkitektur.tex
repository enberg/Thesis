\section{Mjukvaruarkitektur}

Arkitekturen designades utgående samma principer som den tekniska arkitekturen. Systemet har designats utgående ifrån skalbarhet. Det vill säga att systemet skall vara lätt att utveckla funktionsmässigt, det skall vara lätt att underhålla systemet och det skall vara lätt att skala upp det vid behov. \citep[s. 203]{scalableweb}

\subsection{Horisontell skalbarhet}

För att tillåta systemet att adapteras till växande resurskrav, har SmartElement designats för att tillåta sig skala horisontellt. Att ett system är horisontellt skalbart betyder att man kan öka systemets kapacitet genom att lägga till instanser.\citep[s. 205-207]{scalableweb}

I SmartElements fall betydde det att mjukvaruarkitekturen måste vara tillräckligt flexibel för att kunna köras på flera instanser. Detta ledde till en modulär design som försöker separera ansvarsområden inom mjukvaran. På så vis att de olika delarna kan byggas ut oberoende av varandra.

Den tyngsta delen av applikationen, vad gäller skalbarhet, är applikationsdatabasen. På grund av detta designades processer som är menade att skydda detta lager genom att spara objekt i cache minne. På så vis hålls databas förfrågningarna lägre och applicationsdatabasen behöver inte skala lika mycket för att systemet skall klara större mängder förfrågningar.

\subsection{Servern}

\begin{figure}[h!]
\centering
\includegraphics[width=120mm]{assets/images/smelementbackendparts.png}
\caption{Delarna av serverkomponenten}
\label{abstractbackend}
\end{figure}

Back-end systemet, eller serverkomponeneten, i SmartElement är den centrala delen av systemet var all data lagras och all filtrering sker. Systemet har två gränssnitt, ett öppet som används av tagen för att hämta innehåll vid sidvisningar, och ett stängt som används av en frontend vid konfiguration.

Hela back-end systemet är designat med en fokus på att vara tillståndslöst (jmfr. engelskans \textit{''stateless''}) vad gäller hanteringen av förfrågningar. I praktiken betyder detta att man inte skall behöva en session med back-enden för att kunna genomföra förfrågningar, utan all information som behövs förses antingen i förfrågan, eller så kan den generaras från databasen. Detta betyder att t.ex. autentikationen är baserad på en nyckel som används för att generera en signatur för varje förfrågan. Orsaken till detta ligger i att det är lättare att skala systemet horisontellt, genom att lägga till applikationsservrar, då sessioner inte behöver synkroniseras mellan de olika servrarna.

Tekniskt sett så finns det fyra huvudsakliga komponenter i back-end systemet som kan skiljas åt: applikationen, caching-lagret, applikations-databasen och statistik-databasen. Denna uppdelning är gjord för att försöka tillåta för oberoende horisontell skalning av resurserna för de olika ansvarsområdena genom att lägga till eller ta bort instanser av de olika komponenterna i takt med behov.

\subsection{PHP-ramverket Laravel}

För att snabba upp utvecklingen av systemet användes ett utvecklingsramverk. Ett utvecklingsramverk är en samling av kodpaket som används som bas vid utvecklingen av en applikation och förser utvecklaren med funktionalitet som inte varierar mycket mellan applikationer.

Ramverket som används för att utveckla SmartElement är PHP-ramverket Laravel. Det är ett yngre ramverk som utvecklats med komponenter från Symfony-ramverket, ett väletablerat PHP-ramverk som dock kan vara rätt tungt. Laravel drar även full nytta av Composer pakethanteraren, vilket tillåter lätt importering av kodpaket i projektet. Utöver detta är hela ramverket uppbyggt för att vara modulärt och tillåter således modifikation och hel ersättning av komponenter.

Laravel-ramverket bygger på ett \gls{mvc} mönster i sin arkitektur. Det vill säga att ramverket delar upp ansvar i olika komponenter: datalager (Model), presentationslager (View) och kontrolllager (Controller). Datalagret ansvarar för applikationslogik och data, presentationslagret ansvarar för att presentera data och kontrolllagret ansvarar för att binda ihop presentations- och datalagret.\citep[s. 14-16]{gof}

\subsection{Komponenter}

\todo{Förklara att vi går in på komponenter i systemet, underlätta context switch}

\subsubsection{Matcher}
\todo[inline]{rename?}

Den centrala delen av hanteringen av en sidvisning sker i den så kallade matchern som tar emot information om besökaren och söker fram det innehåll som skall skickas tillbaka. Rent tekniskt så tar matchern besökarobjektet, synkroniserar statistikdatabasen med besökarobjektet, söker fram sidobjektet ur cachinglagret (alternativt bygger det från databasen), använder sidobjektet för att generera det innehåll som skall sändas tillbaka och formaterar ett svar som skickas tillbaka till klienten.

\subsubsection{Besökarobjektet}

Besökarobjektet representerar en besökare på webbsidan och innehåller all information som systemet kunnat samla ihop. Besökarobjektet är det enda objekt i filtreringsprocessen som är designat att röra databasen.

När en förfrågan kommer in, kallas en metod som försöker hitta besökaren i statistikdatabasen. Om ett resultat hittas, uppdaterars det befintliga objektet med den nya informationen från förfrågningen. Om besökaren inte är igenkänd så skapas ett nytt besökarobjekt med den försedda informationen.

\subsubsection{Site objektet}

\input{assets/uml/site}

Sidobjektet är det högsta objektet i hierarkin som används för att filtrera ut innehåll. det beskriver användarens webbplats i sin helhet. Från sidobjektet går alla relationer enda ner till filtren som används för att välja ut innehåll.

När matchern samlar ihop data för att skicka tillbaka till klienten så kallar den på siteobjektet med ett besökarobjekt och därefter sköter siteobjektet om att kalla på de olika elementen som sparats under sidan och ber dessa filtrera ut lämpligt innehåll innan det lämnar tillbaka kontrollen till matchern.

Objektet är designat så att det kan kompileras till en entitet som går att spara i ett caching-lager för kunna hålla objekten i minne vid operation. Detta tillåter snabb åtkomst till data under en sidvisning och sparar på databasförfrågningar.

\subsubsection{Element objekten}

\input{assets/uml/element}

Element objekten motsvarar ett HTML element på användarens webbplats, men de är ej bundna till någon specifik webbadress eller sida på webbplatsen. Detta betyder att man kan använda samma element på olika sidor under samma webbplats om man vill, t.ex. i en side-bar eller som del av en navigation.

\subsubsection{FilterSet objekten}

\input{assets/uml/filterset}

Ett element innehåller filterset, innehåll och ett status. Filterseten är samlingar av filter med en länk till ett innehållsobjekt samt en prioritet inom elementet. När sidobjektet kallar på ett element för att få tillbaka det passliga innehållet kör elementet igenom sin samling filter set och ser om de passar besökarobjektet. Om fler en ett filterset passar så väljs det med högsta prioritet. När ett filterset valts ut så returnerar elementet det innehåll som filtersetet är länkat till. Om inget filterset passar så returneras ett tomt resultat.

Filterseten bygger tillsammans med filtren på en design princip som kallas för ''Strategy pattern''. Idén är att man genom att definiera ett bra gränssnitt för en process, lämnar systemet öppet för enkel vidareutveckling i ett senare skede. \citep[s. 349]{gof} FilterSet objektet i samband med Besökar objektet utgör tillsammans det kontext i vilket strategierna (Filtren) appliceras.

\subsubsection{Filter objekten}

\input{assets/uml/filter}

Filterobjekten är i slutändan de objekt som utför test mot besökarobjektet. De består av en filtertyp som definierar hur de jämför data, ett fält-id som de använder för att läsa ut data ur besökarobjektet, ett värde som de testar mot och ett villkor som de använder för att utföra testet.

Filterobjekten implementerar strategin i filtreringen som utförs i samband med filterseten. Filter tar endast ställning till en sak och returnerar ett booleanskt värde beroende på om kriteriet möts eller ej. Filtersetet vet endast att det kan ställa frågan av godtyckligt filter och filtret i sig vet att frågan alltid kommer att ställas på samma vis med likadan input.

\subsubsection{Content objekten}

\input{assets/uml/content}

Content objektet är den data som returneras till klienten efter att filtreringen skett. Systemet sätter ingen restriktion på datan annan än att det måste kunna sparas som en textsträng. Detta betyder att man kan producera avancerad funktionalitet genom att t.ex. spara javascript-kod eller \gls{json}-data som innehåll och på så vis använda SmartElement för att styra exekvering på klienten. Det betyder också att systemet inte sätter så stora krav på kallaren eftersom det enda som är viktigt är att klienten kan tolka datan som returneras. Detta betyder att man i princip kunde skapa godtycklig klient till back-enden genom att implementera protokollet som tagen använder.\todo{bilaga med protokoll?}

\subsection{Javascript tagen}

Javascript tagen är en kort kod som laddas i samband med sidan och samlar ihop information om användaren och sedan skickar denna information till back-end systemet för processering.

Tagen börjar med att skapa en kaka på klienten om ingen redan existerar, skapar det besökar id som genom systemet används för att identifiera besökaren, registrerar tiden för sidvisningen, beräknar besökets längd, samlar ihop data om besökaren och sänder den till back-enden.\todo{red upp va sjutton du försöker förklara}

Efter att back-enden processerat förfrågan och returnerat data för de element som begärts så är standardbeteendet att back-enden genom ett \gls{jsonp}-svar kallar på tagen som uppdaterar dokumentet med det returnerade innehållet. Vilken funktion som kallas kan dock ändras och man kan genom att specificera en callback ändra på funktionskallet i \gls{jsonp}-svaret och på så vis använda egen logik för uppdateringen av innehållet.

\subsection{Begränsningar}

Systemet utvecklades med relativt låg budget och därigenom en del begränsningar på tekniken och hårdvaran som fanns tillgänglig. Detta återspeglar sig i en del begränsningar i själva systemet samt i funktionalitet som inte implementerats.
\todo[inline]{Is this necessary?}


% vim: set tw=78:ts=2:sw=2:et:fdm=marker:wrap:wm=78:ft=tex
% vim: spell spelllang=sv
